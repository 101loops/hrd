package hrd

import (
	"time"
)

type Saver struct {
	coll *Collection
	opts *operationOpts
}

func newSaver(coll *Collection) *Saver {
	return &Saver{coll, coll.opts.clone()}
}

func (self *Saver) Flags(flags ...Flag) *Saver {
	self.opts = self.opts.Flags(flags...)
	return self
}

func (self *Saver) WithKey(complete ...bool) *Saver {
	self.opts = self.opts.CompleteKeys(complete...)
	return self
}

// ==== CACHE

func (self *Saver) NoCache() *Saver {
	return self.NoLocalCache().NoGlobalCache()
}

func (self *Saver) NoLocalCache() *Saver {
	self.opts = self.opts.NoLocalCache()
	return self
}

func (self *Saver) NoGlobalCache() *Saver {
	return self.CacheExpire(-1)
}

func (self *Saver) CacheExpire(exp time.Duration) *Saver {
	self.opts = self.opts.CacheExpire(exp)
	return self
}

// ==== EXECUTE

// Entity saves the passed entity into the datastore.
// If its key is incomplete, the returned key will be a unique key generated by the datastore.
func (self *Saver) Entity(src interface{}) (*Key, error) {
	keys, err := self.put(src)
	if len(keys) == 1 {
		return keys[0], err
	}
	return nil, err
}

// Entities is a batch version of Entity.
func (self *Saver) Entities(srcs interface{}) ([]*Key, error) {
	return self.put(srcs)
}

func (self *Saver) put(src interface{}) ([]*Key, error) {
	docs, err := newReadableDocs(self.coll, src)
	if err != nil {
		return nil, err
	}
	return self.coll.store.putMulti(self.coll.name, docs, self.opts)
}
